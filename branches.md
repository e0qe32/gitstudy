# Основные команды работы с ветками в GIT

*git branch* – посмотреть список веток в репозитории

**git branch <название ветки>** – создать новую ветку с именем <название ветки>

_git checkout <название ветки>_ – переход к другой ветке с именем <название ветки>

__git branch -d <название ветки>__ – удалить ветку с именем <название ветки>

*git log –graph* - визуализирует коммиты

**git checkout -b <название ветки>** - cоздание и переход в новую ветку с именем <название ветки>

*git merge* **<название ветки>** - слияние master и ветки с именем <название ветки>

## HEAD

*HEAD* - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данный момент работаем.

HEAD всегда указывает на последний коммит из вашего локального дерева. Большинство команд Git, изменяющих рабочее дерево, начнут с изменения HEAD.

Обычно HEAD указывает на имя ветки (например, bugFix). Когда вы делаете коммит, статус ветки bugFix меняется и это изменение видно через HEAD.

### Detaching HEAD

Отделение (detaching) HEAD означает лишь присвоение его не ветке, а конкретному коммиту.

## Относительные ссылки

Передвигаться по дереву Git при помощи указания хешей коммитов немного неудобно. В реальной ситуации у вас вряд ли будет красивая визуализация дерева в терминале, так что придётся каждый раз использовать git log, чтобы найти хеш нужного коммита.

Более того, хеши в реальном репозитории Git намного более длинные.

Хорошая новость в том, что Git достаточно умён в работе с хешами. Ему нужны лишь первые несколько символов для того, чтобы идентифицировать конкретный коммит. Так что можно написать просто первые 4 символа вместо полного хеша.

Как мы уже говорили, указание на коммит при помощи его хеша - не самый удобный способ, поэтому Git поддерживает относительные ссылки.

С относительными ссылками можно начать с какого-либо удобного места (например, с ветки bugFix или от HEAD) и двигаться от него.

Относительные ссылки - мощный инструмент, но мы покажем два простых способа использования:
* Перемещение на один коммит назад ^
* Перемещение на несколько коммитов назад ~<num>

Для начала рассмотрим оператор каретки (^). Когда мы добавляем его к имени ссылки, Git воспринимает это как указание найти родителя указанного коммита.

Так что main^ означает "первый родитель ветки main".

main^^ означает прародитель (родитель родителя) main

### Оператор "~"

Предположим, нужно переместиться на много шагов назад по дереву. Было бы неудобно печатать ^ несколько раз (или несколько десятков раз), так что Git поддерживает также оператор тильда (~).
  
К тильде (опционально) можно добавить количество родительских коммитов, через которые нужно пройти. Укажем после ~ число коммитов, через которые надо пройти git checkout HEAD~4.
  
### Перемещение ветки (branch forcing)
  
Теперь мы разбираемся в относительных ссылках, так что можно реально использовать их для дела.
  
Одна из наиболее распространённых целей, для которых используются относительные ссылки - это перемещение веток. Можно напрямую прикрепить ветку к коммиту при помощи опции -f. Например, команда:

git branch -f main HEAD~3 переместит (принудительно) ветку main на три родителя назад от HEAD.
  
Относительная ссылка дала нам возможность просто сослаться на C1, а branch forcing (-f) позволил быстро переместить указатель ветки на этот коммит.

## Отмена изменений в Git

Есть два основных способа отмены изменений в Git: первый - это git reset, а второй - git revert.

### Git Reset

git reset отменяет изменения, перенося ссылку назад, на более старый коммит. Это своего рода "переписывание истории"; git reset перенесёт ветку назад, как будто некоторых коммитов вовсе и не было.

### Git Revert

Reset отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи.

Чтобы отменить изменения и поделиться отменёнными изменениями с остальными, надо использовать git revert.

## Git Cherry-pick

Первая из таких команд - это git cherry-pick. Она выглядит вот так:

* git cherry-pick <Commit1> <Commit2> <...>

Это очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находится (HEAD). Мы обожаем cherry-pick за то, что в нём очень мало магии и его очень просто понять и применять.

## Git Interactive Rebase

Git cherry-pick прекрасен, когда точно известно, какие коммиты нужны (и известны их точные хеши).

Но как быть в случае, когда точно не известно какие коммиты нужны? К счастью, Git позаботился о таких ситуациях! Можно использовать интерактивный rebase для этого - лучший способ отобрать набор коммитов для rebase.

Всё, что нужно для интерактивного rebase - это опция -i

Если добавить эту опцию, Git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель rebase (target). Также показываются хеши коммитов и комментарии к ним, так что можно легко понять что к чему.

Для "реального" Git, этот интерфейс означает просто открытие файла в редакторе типа vim.

После открытия окна интерактивного rebase есть три варианта для каждого коммита:

* Можно сменить положение коммита по порядку, переставив строчку с ним в редакторе.

* Можно "выкинуть" коммит из ребейза. Для этого есть pick - переключение его означает, что нужно выкинуть коммит.

* Наконец, можно соединить коммиты.



  
  
  
  
  
  

